{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Main","text":""},{"location":"#backend-engineering-notes","title":"Backend Engineering Notes","text":"<p>A living knowledge base on backend engineering, architecture, databases, and scalability.</p>"},{"location":"#about-this-site","title":"About This Site","text":"<p>I'm building a comprehensive knowledge base for backend engineering. These are my raw notes, code examples, and insights  from building production systems.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<p>TypeScript, Go, PostgreSQL, Redis, Kafka, Docker, Kubernetes</p>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/","title":"NestJS Service Layer Types - Best Practices","text":""},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#the-problem","title":"The Problem","text":"<p>When your service methods return only specific fields from your database models, what type should you use? Should services return DTOs?</p>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#the-solution-domain-types-not-dtos","title":"The Solution: Domain Types, Not DTOs","text":"<p>Services should return domain types, not DTOs. DTOs belong to the transport layer (controllers), while services operate on domain concepts.</p>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#example-structure","title":"Example Structure","text":"<pre><code>// domain/product.types.ts\nexport type Product = {\n    id: string;\n    sku: string;\n    name: string;\n    price: number;\n    description?: string;\n    imageUrl?: string;\n};\n</code></pre> <pre><code>// catalog.service.ts\nimport { Product } from './domain/product.types';\n\n@Injectable()\nexport class CatalogService {\n    constructor(private readonly prisma: PrismaService) {}\n\n    async findOne(sku: string): Promise&lt;Product&gt; {\n        const product = await this.prisma.product.findUnique({\n            where: { sku },\n            select: {\n                id: true,\n                sku: true,\n                name: true,\n                price: true,\n                description: true,\n                imageUrl: true,\n            }\n        });\n\n        if (!product) {\n            throw new ProductNotFoundException(`${sku} not found`);\n        }\n\n        return product;\n    }\n}\n</code></pre> <pre><code>// dto/product-response.dto.ts\nexport class ProductResponseDto {\n    id: string;\n    sku: string;\n    name: string;\n    price: number;\n    description?: string;\n    imageUrl?: string;\n}\n</code></pre> <pre><code>// catalog.controller.ts\n@Controller('products')\nexport class CatalogController {\n    constructor(private readonly catalogService: CatalogService) {}\n\n    @Get(':sku')\n    async findOne(@Param('sku') sku: string): Promise&lt;ProductResponseDto&gt; {\n        return await this.catalogService.findOne(sku);\n    }\n}\n</code></pre>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#layer-separation","title":"Layer Separation","text":"Layer Type Purpose Service Domain Type (<code>Product</code>) Business logic and domain operations Controller DTO (<code>ProductResponseDto</code>) HTTP transport and serialization"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Separation of Concerns: Services shouldn't know about HTTP, REST, or GraphQL</li> <li>Reusability: Domain types can be used across different transport layers (REST, GraphQL, gRPC)</li> <li>Flexibility: DTOs and domain types can diverge independently (computed fields, formatting, etc.)</li> <li>Testability: Services remain transport-agnostic and easier to test</li> </ul>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#when-types-diverge","title":"When Types Diverge","text":"<p>If your API needs different data than your service provides, map between them in the controller:</p> <pre><code>@Get(':sku')\nasync findOne(@Param('sku') sku: string): Promise&lt;ProductResponseDto&gt; {\n    const product = await this.catalogService.findOne(sku);\n\n    return {\n        ...product,\n        priceFormatted: `$${product.price.toFixed(2)}`, // DTO-specific field\n    };\n}\n</code></pre>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#exception-handling-return-types","title":"Exception Handling: Return Types","text":"<p>When your service throws exceptions instead of returning <code>null</code>, reflect this in the return type:</p> <pre><code>// \u274c Incorrect - suggests null can be returned\nasync findOne(sku: string): Promise&lt;Product | null&gt;\n\n// \u2705 Correct - method either returns Product or throws\nasync findOne(sku: string): Promise&lt;Product&gt;\n</code></pre> <p>The exception becomes part of your method's contract. Callers know that if the method returns, they have a valid <code>Product</code>.</p>"},{"location":"architecture/NestJS%20Service%20Layer%20Types%20-%20Best%20Practices/#summary","title":"Summary","text":"<ul> <li>Use domain types in services for business logic</li> <li>Use DTOs in controllers for transport concerns</li> <li>Let TypeScript infer when possible, but be explicit about contracts</li> <li>Throw exceptions for error cases; don't pollute return types with <code>null</code> unnecessarily</li> <li>Keep layers independent and focused on their responsibilities</li> </ul>"},{"location":"architecture/domain-exceptions-in-ts/","title":"Designing Domain Exceptions in TypeScript","text":"<p>By Labeeb | Backend Engineer | Clean Architecture</p> <p>In layered architectures, domain or business exceptions must not inherit from transport-specific exceptions like HTTP exceptions. They represent business rule violations, not technical or transport failures.</p>"},{"location":"architecture/domain-exceptions-in-ts/#domainexception-base-class-for-business-errors","title":"DomainException: Base Class for Business Errors","text":"<pre><code>export abstract class DomainException extends Error {\n  readonly abstract code: string;\n\n  constructor(message: string) {\n    super(message);\n\n    // Fix prototype chain so `instanceof` works correctly\n    Object.setPrototypeOf(this, new.target.prototype);\n\n    // Set class name for stack traces and logging\n    this.name = new.target.name;\n  }\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>extends Error</code> ensures compatibility with JS runtime and logging tools.</li> <li><code>Object.setPrototypeOf(this, new.target.prototype)</code> fixes the broken inheritance when extending <code>Error</code>.</li> <li><code>this.name = new.target.name</code> sets a meaningful class name in stack traces.</li> <li><code>code</code> provides a machine-readable identifier for the exception.</li> </ul>"},{"location":"architecture/domain-exceptions-in-ts/#example-productnotfound-exception","title":"Example: ProductNotFound Exception","text":"<pre><code>export class ProductNotFound extends DomainException {\n  code: string = 'ProductNotFound';\n\n  constructor(message: string) {\n    super(message);\n  }\n}\n</code></pre> <p>Why this matters:</p> <ul> <li>The exception represents a business invariant violation (product missing).</li> <li>It is transport-agnostic: controllers, HTTP, gRPC, or message queues can handle it separately.</li> <li>Enables clean architecture, keeping domain logic independent from infrastructure.</li> </ul>"},{"location":"architecture/domain-exceptions-in-ts/#summary","title":"Summary","text":"<ul> <li>Domain exceptions are for business rules, not HTTP or transport errors.</li> <li>Base class ensures consistent prototype chain, stack traces, and codes.</li> <li>Subclasses like <code>ProductNotFound</code> define specific domain errors while remaining reusable and testable.</li> </ul> <p>This pattern makes your domain logic predictable, maintainable, and decoupled from the delivery layer.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/","title":"Layered Architecture &amp; Exception Handling Guide","text":"<p>A comprehensive guide to exception handling patterns in layered architecture for building maintainable, reusable systems.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Principles</li> <li>The Golden Rule</li> <li>Layer Responsibilities</li> <li>Exception Flow</li> <li>Design Patterns</li> <li>Trade-offs</li> <li>Real-World Examples</li> <li>Anti-Patterns</li> <li>Quick Reference</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#core-principles","title":"Core Principles","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#1-layers-depend-on-the-layer-below","title":"1. Layers Depend on the Layer Below","text":"<pre><code>Controller/Adapter\n    \u2193 depends on\nService/Domain\n    \u2193 depends on\nRepository/Infrastructure\n</code></pre> <p>Never reverse: Domain should never import from Controller.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#2-domain-must-be-transport-agnostic","title":"2. Domain Must Be Transport-Agnostic","text":"<p>The domain layer should not know about HTTP, CLI, queues, or any delivery mechanism.</p> <pre><code>// \u274c Bad - domain knows about HTTP\nthrow new NotFoundException() // HTTP-specific\n\n// \u2705 Good - domain exception\nthrow new UserNotFound() // Pure domain\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#3-fail-fast","title":"3. Fail Fast","text":"<p>Throw immediately when something is wrong. Don't continue execution in an invalid state.</p> <pre><code>async createOrder(userId: string, productId: string) {\n  const user = await this.getUser(userId)\n  if (!user) throw new UserNotFound() // Stop immediately\n\n  const product = await this.getProduct(productId)\n  if (!product) throw new ProductNotFound() // Stop immediately\n\n  // Happy path continues\n  return this.orderRepo.create({ user, product })\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#4-let-exceptions-bubble","title":"4. Let Exceptions Bubble","text":"<p>Don't catch exceptions unless you're actually handling them. Let them propagate to the appropriate layer.</p> <pre><code>// \u274c Bad - exception buried\ntry {\n  await service.createOrder(data)\n} catch (e) {\n  console.log('Error:', e)\n  // Exception dies here!\n}\n\n// \u2705 Good - let it bubble\nawait service.createOrder(data)\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#the-golden-rule","title":"The Golden Rule","text":"<p>When to throw vs. return optional values:</p> <p>If the caller could reasonably branch on the result \u2192 return <code>null</code> / <code>Result</code></p> <p>If continuing execution would be incorrect \u2192 throw</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#examples","title":"Examples","text":"<p>Return null for queries:</p> <pre><code>async findProduct(sku: string): Promise&lt;Product | null&gt; {\n  return this.prisma.product.findUnique({ where: { sku } })\n}\n</code></pre> <p>Throw for commands:</p> <pre><code>async getProductOrThrow(sku: string): Promise&lt;Product&gt; {\n  const product = await this.prisma.product.findUnique({ where: { sku } })\n  if (!product) throw new ProductNotFound()\n  return product\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#layer-responsibilities","title":"Layer Responsibilities","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#repository-layer","title":"Repository Layer","text":"<p>Responsibility: Answer data questions</p> <pre><code>class ProductRepository {\n  async findById(id: string): Promise&lt;Product | null&gt; {\n    return this.prisma.product.findUnique({ where: { id } })\n  }\n}\n</code></pre> <ul> <li>Returns <code>null</code> for \"not found\"</li> <li>Throws infrastructure exceptions (DB errors, network timeouts)</li> <li>No business logic</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#servicedomain-layer","title":"Service/Domain Layer","text":"<p>Responsibility: Enforce business rules and invariants</p> <pre><code>class OrderService {\n  async createOrder(userId: string, sku: string) {\n    // Enforce invariants - throw if violated\n    const user = await this.userService.getOrThrow(userId)\n    const product = await this.productService.getOrThrow(sku)\n\n    if (product.stock &lt; 1) {\n      throw new OutOfStock(sku)\n    }\n\n    return this.orderRepo.create({ user, product })\n  }\n}\n</code></pre> <ul> <li>Throws domain exceptions when invariants are violated</li> <li>Does NOT catch its own exceptions (usually)</li> <li>May translate infrastructure exceptions to domain exceptions</li> <li>Transport-agnostic (doesn't know about HTTP/CLI)</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#controlleradapter-layer","title":"Controller/Adapter Layer","text":"<p>Responsibility: Translate between domain and external world</p> <pre><code>@Post('/orders')\nasync createOrder(@Body() dto: CreateOrderDto) {\n  try {\n    const order = await this.orderService.createOrder(dto.userId, dto.sku)\n    return { status: 201, data: order }\n  } catch (e) {\n    if (e instanceof UserNotFound) \n      throw new NotFoundException('User not found')\n    if (e instanceof ProductNotFound) \n      throw new NotFoundException('Product not found')\n    if (e instanceof OutOfStock) \n      throw new BadRequestException('Product out of stock')\n    throw e\n  }\n}\n</code></pre> <ul> <li>Catches domain exceptions</li> <li>Translates to transport responses (HTTP status codes, CLI exit codes, etc.)</li> <li>Validates input shape (not business rules)</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#global-exception-handler","title":"Global Exception Handler","text":"<p>Responsibility: Safety net for unhandled exceptions</p> <pre><code>@Catch()\nexport class GlobalExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp()\n    const response = ctx.getResponse()\n\n    this.logger.error('Unhandled exception', exception)\n\n    if (exception instanceof UserNotFound) {\n      return response.status(404).json({ message: 'User not found' })\n    }\n\n    if (exception instanceof DatabaseError) {\n      this.alerting.criticalError(exception)\n    }\n\n    return response.status(500).json({ message: 'Internal server error' })\n  }\n}\n</code></pre> <ul> <li>Catches all unhandled exceptions</li> <li>Centralizes exception-to-HTTP mapping</li> <li>Logs and monitors</li> <li>Returns appropriate error responses</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#exception-flow","title":"Exception Flow","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#visual-flow","title":"Visual Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client Request                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Controller/Adapter                               \u2502\n\u2502 try {                                            \u2502\n\u2502   service.createOrder()                          \u2502 \u2190 Catches &amp; translates\n\u2502 } catch (DomainException) {                      \u2502\n\u2502   \u2192 404, 400, 409, etc.                         \u2502\n\u2502 }                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Service/Domain                                   \u2502\n\u2502 - Enforces invariants                            \u2502\n\u2502 - Throws domain exceptions                       \u2502 \u2190 Throws, doesn't catch\n\u2502 - NO try-catch (unless translating)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Repository/Infrastructure                        \u2502\n\u2502 - DB errors, network errors                      \u2502\n\u2502 - Throws infrastructure exceptions               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2193 (if not caught in controller)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Global Exception Handler                         \u2502\n\u2502 - Logs unexpected errors                         \u2502 \u2190 Safety net\n\u2502 - Returns 500                                    \u2502\n\u2502 - Alerts monitoring                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#who-handles-what","title":"Who Handles What?","text":"Exception Type Usually Handled By Alternative Domain exceptions Controller or Global Handler - Database errors Controller or Global Handler Domain (if translating) Network timeouts Global Handler Controller (if specific handling) Validation errors Domain (throws immediately) - Business rule violations Domain (throws) -"},{"location":"architecture/layered-architecture-exceptions-handling/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#pattern-1-let-exceptions-bubble-most-common","title":"Pattern 1: Let Exceptions Bubble (Most Common)","text":"<pre><code>// Repository\nclass ProductRepository {\n  async findById(id: string) {\n    return this.prisma.product.findUnique({ where: { id } })\n    // Can throw: PrismaClientKnownRequestError, NetworkError, etc.\n  }\n}\n\n// Service - does NOT catch\nclass OrderService {\n  async createOrder(productId: string) {\n    const product = await this.productRepo.findById(productId)\n    // If DB error happens, it just bubbles up\n  }\n}\n\n// Controller - catches everything\ntry {\n  await orderService.createOrder(productId)\n} catch (e) {\n  if (e instanceof ProductNotFound) throw new NotFoundException()\n  if (e instanceof PrismaClientKnownRequestError) {\n    throw new ServiceUnavailableException('Database error')\n  }\n  throw e\n}\n</code></pre> <p>When to use: Most of the time. Simple, predictable, works well.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#pattern-2-translate-at-domain-boundary","title":"Pattern 2: Translate at Domain Boundary","text":"<pre><code>// Service - translates infrastructure \u2192 domain\nclass OrderService {\n  async createOrder(productId: string) {\n    try {\n      const product = await this.productRepo.findById(productId)\n    } catch (e) {\n      if (e instanceof PrismaClientKnownRequestError) {\n        throw new ProductRepositoryError('Failed to fetch product')\n      }\n      throw e\n    }\n  }\n}\n\n// Controller - only handles domain errors\ntry {\n  await orderService.createOrder(productId)\n} catch (e) {\n  if (e instanceof ProductRepositoryError) {\n    throw new ServiceUnavailableException()\n  }\n  throw e\n}\n</code></pre> <p>When to use: When you want to hide infrastructure details, or might swap implementations later.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#pattern-3-exception-mapper-helper","title":"Pattern 3: Exception Mapper Helper","text":"<pre><code>// exception-mapper.ts\nexport class ExceptionMapper {\n  static toHttp(error: Error): HttpException {\n    if (error instanceof UserNotFound) \n      return new NotFoundException('User not found')\n    if (error instanceof ProductNotFound) \n      return new NotFoundException('Product not found')\n    if (error instanceof InsufficientStock) \n      return new BadRequestException('Out of stock')\n    if (error instanceof DuplicateOrder) \n      return new ConflictException('Order exists')\n\n    return new InternalServerErrorException()\n  }\n}\n\n// Controller - clean\ntry {\n  return await service.createOrder(data)\n} catch (e) {\n  throw ExceptionMapper.toHttp(e)\n}\n</code></pre> <p>When to use: When you have many exception types and want centralized mapping.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#pattern-4-global-exception-filter-recommended","title":"Pattern 4: Global Exception Filter (Recommended)","text":"<pre><code>// Service - just throws domain exceptions\nclass OrderService {\n  async createOrder(data) {\n    if (!user) throw new UserNotFound()\n    if (!product) throw new ProductNotFound()\n  }\n}\n\n// Controller - no try-catch at all!\n@Post('/orders')\nasync createOrder(@Body() data: CreateOrderDto) {\n  return await this.orderService.createOrder(data)\n  // Let exceptions bubble to global filter\n}\n\n// Global filter - handles ALL exceptions\n@Catch()\nexport class DomainExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const response = host.switchToHttp().getResponse()\n\n    if (exception instanceof UserNotFound) {\n      return response.status(404).json({ message: 'User not found' })\n    }\n    if (exception instanceof ProductNotFound) {\n      return response.status(404).json({ message: 'Product not found' })\n    }\n\n    return response.status(500).json({ message: 'Internal error' })\n  }\n}\n</code></pre> <p>When to use: Recommended for most applications. Keeps controllers clean, centralizes mapping.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#pattern-5-result-type-functional-approach","title":"Pattern 5: Result Type (Functional Approach)","text":"<pre><code>type Result&lt;T, E&gt; = \n  | { ok: true; value: T } \n  | { ok: false; error: E }\n\n// Service\nasync createOrder(userId: string): Promise&lt;Result&lt;Order, OrderError&gt;&gt; {\n  const userResult = await this.userRepo.findById(userId)\n  if (!userResult.ok) return { ok: false, error: 'UserNotFound' }\n\n  return { ok: true, value: order }\n}\n\n// Controller\nconst result = await service.createOrder(userId)\nif (!result.ok) {\n  return this.handleError(result.error)\n}\nreturn result.value\n</code></pre> <p>When to use: Functional programming style, when you want explicit error handling, inspired by Rust/Go.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#trade-offs","title":"Trade-offs","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#the-core-trade-off","title":"The Core Trade-off","text":"<pre><code>Option A: Domain throws generic/domain exceptions\n  \u2705 Domain is reusable across transports (HTTP, CLI, Queue)\n  \u274c Controller must know all possible exceptions\n  \u274c Controller does more work\n\nOption B: Domain throws transport-specific exceptions\n  \u2705 Controller is simpler\n  \u274c Domain is coupled to HTTP\n  \u274c Can't reuse in non-HTTP contexts\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#decision-matrix","title":"Decision Matrix","text":"Approach Domain Work Controller Work Reusability When to Use Domain throws HTTP exceptions Low Low \u274c Low Simple apps, single transport Domain throws + Controller catches Medium High \u2705 High Multiple transports needed Domain throws + Global filter Medium Low \u2705 High Recommended for most Result types High Medium \u2705 High Functional style"},{"location":"architecture/layered-architecture-exceptions-handling/#choosing-based-on-context","title":"Choosing Based on Context","text":"<p>Single HTTP API: - Use global exception filter - Trade-off: Worth it, clean controllers</p> <p>Multiple Transports (HTTP + CLI + Queue): - Domain throws pure exceptions - Each adapter translates - Trade-off: Worth it, true reusability</p> <p>Simple CRUD App: - Domain can throw HTTP exceptions directly - Trade-off: Simplicity over \"perfect\" architecture</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#real-world-examples","title":"Real-World Examples","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#example-1-e-commerce-order-creation","title":"Example 1: E-commerce Order Creation","text":"<pre><code>// Domain exceptions\nclass UserNotFound extends Error {}\nclass ProductNotFound extends Error {}\nclass OutOfStock extends Error {}\n\n// Repository\nclass ProductRepository {\n  async findBySku(sku: string): Promise&lt;Product | null&gt; {\n    return this.prisma.product.findUnique({ where: { sku } })\n  }\n}\n\n// Service\nclass OrderService {\n  async createOrder(userId: string, sku: string, quantity: number) {\n    // Enforce invariants\n    const user = await this.userRepo.findById(userId)\n    if (!user) throw new UserNotFound(`User ${userId} not found`)\n\n    const product = await this.productRepo.findBySku(sku)\n    if (!product) throw new ProductNotFound(`Product ${sku} not found`)\n\n    if (product.stock &lt; quantity) {\n      throw new OutOfStock(`Only ${product.stock} units available`)\n    }\n\n    // Happy path\n    await this.productRepo.decrementStock(sku, quantity)\n    return this.orderRepo.create({ userId, sku, quantity })\n  }\n}\n\n// Controller\n@Post('/orders')\nasync createOrder(@Body() dto: CreateOrderDto) {\n  // Option 1: Handle in controller\n  try {\n    const order = await this.orderService.createOrder(\n      dto.userId, \n      dto.sku, \n      dto.quantity\n    )\n    return { status: 201, data: order }\n  } catch (e) {\n    if (e instanceof UserNotFound) \n      throw new NotFoundException(e.message)\n    if (e instanceof ProductNotFound) \n      throw new NotFoundException(e.message)\n    if (e instanceof OutOfStock) \n      throw new BadRequestException(e.message)\n    throw e\n  }\n\n  // Option 2: Let global filter handle it\n  return await this.orderService.createOrder(\n    dto.userId, \n    dto.sku, \n    dto.quantity\n  )\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#example-2-payment-processing","title":"Example 2: Payment Processing","text":"<pre><code>// Domain\nclass PaymentService {\n  async processPayment(orderId: string, amount: number) {\n    const order = await this.orderRepo.findById(orderId)\n    if (!order) throw new OrderNotFound()\n\n    if (order.status === 'paid') {\n      throw new OrderAlreadyPaid()\n    }\n\n    // Call external payment gateway\n    try {\n      const result = await this.paymentGateway.charge(amount)\n      await this.orderRepo.markAsPaid(orderId, result.transactionId)\n      return result\n    } catch (e) {\n      // Translate infrastructure error to domain error\n      if (e instanceof GatewayTimeout) {\n        throw new PaymentGatewayUnavailable()\n      }\n      if (e instanceof InsufficientFunds) {\n        throw new PaymentDeclined('Insufficient funds')\n      }\n      throw new PaymentFailed('Payment processing failed')\n    }\n  }\n}\n\n// Controller\n@Post('/payments')\nasync processPayment(@Body() dto: ProcessPaymentDto) {\n  try {\n    const result = await this.paymentService.processPayment(\n      dto.orderId, \n      dto.amount\n    )\n    return { status: 200, data: result }\n  } catch (e) {\n    if (e instanceof OrderNotFound) \n      throw new NotFoundException('Order not found')\n    if (e instanceof OrderAlreadyPaid) \n      throw new ConflictException('Order already paid')\n    if (e instanceof PaymentDeclined) \n      throw new BadRequestException(e.message)\n    if (e instanceof PaymentGatewayUnavailable) \n      throw new ServiceUnavailableException('Payment gateway unavailable')\n    throw e\n  }\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#example-3-user-registration","title":"Example 3: User Registration","text":"<pre><code>// Domain\nclass UserService {\n  async registerUser(email: string, password: string) {\n    // Validate business rules\n    if (!this.isValidEmail(email)) {\n      throw new InvalidEmail('Email format is invalid')\n    }\n\n    if (password.length &lt; 8) {\n      throw new WeakPassword('Password must be at least 8 characters')\n    }\n\n    // Check uniqueness\n    const existing = await this.userRepo.findByEmail(email)\n    if (existing) {\n      throw new UserAlreadyExists('Email already registered')\n    }\n\n    // Hash password and create user\n    const hashedPassword = await this.hashPassword(password)\n    return this.userRepo.create({ email, password: hashedPassword })\n  }\n\n  private isValidEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)\n  }\n}\n\n// Global Exception Filter\n@Catch()\nexport class GlobalExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp()\n    const response = ctx.getResponse()\n\n    // Domain exceptions\n    if (exception instanceof InvalidEmail) {\n      return response.status(400).json({ \n        message: exception.message,\n        field: 'email'\n      })\n    }\n\n    if (exception instanceof WeakPassword) {\n      return response.status(400).json({ \n        message: exception.message,\n        field: 'password'\n      })\n    }\n\n    if (exception instanceof UserAlreadyExists) {\n      return response.status(409).json({ message: exception.message })\n    }\n\n    // Infrastructure exceptions\n    if (exception instanceof DatabaseError) {\n      this.logger.error('Database error', exception)\n      return response.status(503).json({ \n        message: 'Service temporarily unavailable' \n      })\n    }\n\n    // Unknown exceptions\n    this.logger.error('Unhandled exception', exception)\n    return response.status(500).json({ message: 'Internal server error' })\n  }\n}\n\n// Controller - stays clean\n@Post('/register')\nasync register(@Body() dto: RegisterDto) {\n  const user = await this.userService.registerUser(dto.email, dto.password)\n  return { status: 201, data: user }\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#anti-patterns","title":"Anti-Patterns","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#anti-pattern-1-swallowing-exceptions","title":"\u274c Anti-Pattern 1: Swallowing Exceptions","text":"<pre><code>// BAD - exception is buried\ntry {\n  await service.createOrder(data)\n} catch (e) {\n  console.log('Error:', e)\n  // Exception dies here!\n}\n\n// GOOD - re-throw or handle\ntry {\n  await service.createOrder(data)\n} catch (e) {\n  console.error('Failed to create order:', e)\n  throw e // Let it bubble\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#anti-pattern-2-domain-knows-about-http","title":"\u274c Anti-Pattern 2: Domain Knows About HTTP","text":"<pre><code>// BAD - domain coupled to HTTP\nclass OrderService {\n  async createOrder(data) {\n    if (!product) {\n      throw new NotFoundException() // HTTP exception in domain!\n    }\n  }\n}\n\n// GOOD - domain exception\nclass OrderService {\n  async createOrder(data) {\n    if (!product) {\n      throw new ProductNotFound() // Domain exception\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#anti-pattern-3-generic-error-messages","title":"\u274c Anti-Pattern 3: Generic Error Messages","text":"<pre><code>// BAD - loses context\ncatch (e) {\n  throw new Error('Something went wrong')\n}\n\n// GOOD - preserve context\ncatch (e) {\n  if (e instanceof UserNotFound) {\n    throw new NotFoundException('User not found')\n  }\n  throw e // Preserve original error\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#anti-pattern-4-catching-without-re-throwing","title":"\u274c Anti-Pattern 4: Catching Without Re-throwing","text":"<pre><code>// BAD - catch-all that hides errors\ntry {\n  await doSomething()\n} catch (e) {\n  return null // Error information lost!\n}\n\n// GOOD - only catch what you handle\ntry {\n  await doSomething()\n} catch (e) {\n  if (e instanceof SpecificError) {\n    return null // Only this specific case\n  }\n  throw e // Re-throw everything else\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#anti-pattern-5-controller-contains-business-logic","title":"\u274c Anti-Pattern 5: Controller Contains Business Logic","text":"<pre><code>// BAD - business logic in controller\n@Post('/orders')\nasync createOrder(@Body() dto: CreateOrderDto) {\n  const product = await this.productRepo.findBySku(dto.sku)\n  if (product.stock &lt; dto.quantity) { // Business rule in controller!\n    throw new BadRequestException('Out of stock')\n  }\n  // ...\n}\n\n// GOOD - business logic in service\n@Post('/orders')\nasync createOrder(@Body() dto: CreateOrderDto) {\n  return await this.orderService.createOrder(dto)\n  // Service handles business rules\n}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#quick-reference","title":"Quick Reference","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#when-to-throw-vs-return-null","title":"When to Throw vs Return Null","text":"Situation Action Layer Invariant violated Throw domain exception Service Optional value Return <code>null</code> or <code>Result</code> Service Infrastructure error (hide details) Catch + translate to domain exception Service Infrastructure error (pass through) Let it bubble Service Need HTTP response Catch + translate to HTTP exception Controller or Global Filter Caught but not handling Re-throw Any"},{"location":"architecture/layered-architecture-exceptions-handling/#exception-handling-checklist","title":"Exception Handling Checklist","text":"<ul> <li>[ ] Domain exceptions are transport-agnostic</li> <li>[ ] Exceptions bubble to appropriate layer</li> <li>[ ] No exceptions are swallowed without logging</li> <li>[ ] Business logic is not in controllers</li> <li>[ ] Infrastructure details are hidden (if needed)</li> <li>[ ] Global exception handler is configured</li> <li>[ ] Error responses are consistent</li> <li>[ ] Exceptions include meaningful messages</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#common-domain-exceptions","title":"Common Domain Exceptions","text":"<pre><code>// Not Found\nclass UserNotFound extends Error {}\nclass ProductNotFound extends Error {}\nclass OrderNotFound extends Error {}\n\n// Validation\nclass InvalidEmail extends Error {}\nclass WeakPassword extends Error {}\nclass InvalidQuantity extends Error {}\n\n// Business Rules\nclass InsufficientStock extends Error {}\nclass OrderAlreadyPaid extends Error {}\nclass UserAlreadyExists extends Error {}\n\n// External Systems\nclass PaymentFailed extends Error {}\nclass PaymentGatewayUnavailable extends Error {}\nclass InventoryServiceUnavailable extends Error {}\n</code></pre>"},{"location":"architecture/layered-architecture-exceptions-handling/#further-reading","title":"Further Reading","text":""},{"location":"architecture/layered-architecture-exceptions-handling/#architectural-patterns","title":"Architectural Patterns","text":"<ul> <li>Domain-Driven Design (DDD) - Eric Evans</li> <li>Wikipedia Overview</li> <li> <p>Focus: Entities, Value Objects, Aggregates, and Invariants</p> </li> <li> <p>Clean Architecture - Robert C. Martin</p> </li> <li>Blog Post</li> <li> <p>Focus: Layered architecture with dependency rules</p> </li> <li> <p>Hexagonal Architecture (Ports &amp; Adapters)</p> </li> <li>Wikipedia</li> <li>Focus: Isolating business logic from interfaces</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#practical-resources","title":"Practical Resources","text":"<ul> <li>Understanding Clean Architecture and DDD</li> <li>Hexagonal Architecture with Examples</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#framework-specific","title":"Framework-Specific","text":"<ul> <li>NestJS: Exception Filters Documentation</li> <li>Spring Boot: <code>@ControllerAdvice</code> pattern</li> <li>ASP.NET: Exception Middleware</li> <li>Express.js: Error handling middleware</li> </ul>"},{"location":"architecture/layered-architecture-exceptions-handling/#license","title":"License","text":"<p>This guide is released under the MIT License. Feel free to use, modify, and share.</p>"},{"location":"architecture/layered-architecture-exceptions-handling/#contributing","title":"Contributing","text":"<p>Found an error or have a suggestion? Please open an issue or submit a pull request.</p> <p>Last Updated: December 20</p>"},{"location":"architecture/overview/","title":"Archirecture","text":"<ul> <li>Exception Handling Guideline</li> <li>Domain Exceptions in Typescript</li> <li>NestJS Service Layer Types - Best Practices</li> <li>Working with Redis Hashes: HSET and HINCRBY</li> </ul>"},{"location":"architecture/redis-hset-and-hincrby/","title":"Working with Redis Hashes: HSET and HINCRBY","text":"<p>Redis hashes are perfect for storing objects with multiple fields. Two essential commands for working with hashes are <code>HSET</code> and <code>HINCRBY</code>.</p>"},{"location":"architecture/redis-hset-and-hincrby/#hset-setting-hash-fields","title":"HSET: Setting Hash Fields","text":"<p><code>HSET</code> stores field-value pairs in a hash. It creates the hash if it doesn't exist and updates fields if they already exist.</p> <p>Syntax:</p> <pre><code>HSET key field value [field value ...]\n</code></pre> <p>Example:</p> <pre><code>HSET user:1000 name \"Alice\" email \"alice@example.com\" age 30\n</code></pre> <p>This creates a hash at key <code>user:1000</code> with three fields. You can set multiple field-value pairs in one command or update them individually:</p> <pre><code>HSET user:1000 age 31\n</code></pre> <p><code>HSET</code> returns the number of fields that were added (not updated).</p>"},{"location":"architecture/redis-hset-and-hincrby/#hincrby-incrementing-hash-values","title":"HINCRBY: Incrementing Hash Values","text":"<p><code>HINCRBY</code> increments a numeric field in a hash by a specified amount. It's atomic and perfect for counters.</p> <p>Syntax:</p> <pre><code>HINCRBY key field increment\n</code></pre> <p>Example:</p> <pre><code>HINCRBY user:1000 login_count 1\n</code></pre> <p>This increments the <code>login_count</code> field by 1. If the field doesn't exist, it's created and set to the increment value.</p> <p>Negative increments work too:</p> <pre><code>HINCRBY user:1000 credits -50\n</code></pre> <p><code>HINCRBY</code> only works with integer values. For floating-point numbers, use <code>HINCRBYFLOAT</code> instead.</p>"},{"location":"architecture/redis-hset-and-hincrby/#common-use-cases","title":"Common Use Cases","text":"<p>User profiles with activity tracking:</p> <pre><code>HSET user:2000 username \"bob\" email \"bob@example.com\"\nHINCRBY user:2000 posts_count 1\nHINCRBY user:2000 points 10\n</code></pre> <p>Product inventory:</p> <pre><code>HSET product:500 name \"Widget\" price 29.99\nHINCRBY product:500 stock -1\n</code></pre>"},{"location":"architecture/redis-hset-and-hincrby/#why-use-hashes","title":"Why Use Hashes?","text":"<p>Hashes let you group related data under one key, making your data model cleaner and more efficient than using separate keys for each field. They're memory-efficient and allow you to retrieve or update individual fields without fetching the entire object.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/","title":"Database Optimization: From Indexes to Partitioning","text":"<p>When a table has no indexes, the database has no shortcuts. Every query forces it to scan all rows, which works at small scale but quickly becomes a bottleneck as data grows.  </p> <p>But what is an index? It\u2019s a data structure that lets the database find rows quickly, avoiding full table scans.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#setup","title":"Setup","text":"<p>In this lab, I will be using PostgreSQL. Make sure you have it installed and ready to use. I recommend using DBeaver as the SQL client to connect to your database and run queries interactively.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#create-the-orders-table","title":"Create the Orders Table","text":"<p>First, I will create a simple <code>orders</code> table:</p> <pre><code>CREATE TABLE orders (\n    id BIGSERIAL PRIMARY KEY,\n    user_id BIGINT,\n    status TEXT,\n    amount NUMERIC,\n    created_at TIMESTAMP\n);\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#seed-the-table-with-sample-data","title":"Seed the Table with Sample Data","text":"<p>Next, I will insert some sample data so I can see how queries behave without indexes:</p> <pre><code>INSERT INTO orders (user_id, status, amount, created_at)\nSELECT\n    (random() * 100)::int,\n    CASE WHEN random() &lt; 0.8 THEN 'completed' ELSE 'pending' END,\n    random() * 500,\n    now() - (random() * interval '30 days')\nFROM generate_series(1, 1000);\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#run-a-query-without-an-index","title":"Run a Query Without an Index","text":"<p>Now I will run a query to find all orders for user_id = 42:</p> <pre><code>SELECT * FROM orders WHERE user_id = 42;\n</code></pre> <p>Since there is no index, PostgreSQL must check every row to find matching results. This is called a full table scan.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#common-developers-mistake","title":"Common developers mistake:","text":"<p>With only a few thousand rows, this might seem fine, which is why many developers test only on empty or small databases. To see the real performance impact, we will generate millions of rows in later steps, simulating a production-scale workload.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#generate-millions-of-records","title":"Generate Millions of Records","text":"<p>To test performance realistically, I will generate 10 million orders. This simulates a production-scale table where full table scans start to become painfully slow.</p> <pre><code>INSERT INTO orders (user_id, status, amount, created_at)\nSELECT\n    (random() * 100000)::int, -- user_id between 0 and 100,000\n    CASE WHEN random() &lt; 0.8 THEN 'completed' ELSE 'pending' END,\n    random() * 500,\n    now() - (random() * interval '365 days')\nFROM generate_series(1, 10000000);\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#notes","title":"Notes:","text":"<ul> <li>user_id is spread across 100,000 users.</li> <li>status is 80% completed, 20% pending.</li> <li>created_at is randomly spread over the past year.</li> <li>generate_series(1, 10000000) creates 10 million rows.</li> </ul> <p>This ensures our queries test realistic load, unlike small or empty databases.</p> <p>To see exactly how PostgreSQL handles this large table, I use EXPLAIN ANALYZE:</p> <pre><code>EXPLAIN ANALYZE\nSELECT * FROM orders WHERE user_id = 42;\n</code></pre> <p>Here is the output of EXPLAIN ANALYZE:</p> <pre><code>Gather  (cost=1000.00..146566.74 rows=98 width=44) (actual time=15.977..566.886 rows=113 loops=1)\n  Workers Planned: 2\n  Workers Launched: 2\n  -&gt;  Parallel Seq Scan on orders  (cost=0.00..145556.94 rows=41 width=44) (actual time=10.467..460.595 rows=38 loops=3)\n        Filter: (user_id = 42)\n        Rows Removed by Filter: 3333629\nPlanning Time: 0.175 ms\nExecution Time: 566.946 ms\n</code></pre> <p>Let\u2019s break it down:</p> <ul> <li> <p><code>Gather</code>: This node collects results from multiple parallel workers. We planned and launched 2 workers, so PostgreSQL splits the table and combines the rows found by each worker.</p> </li> <li> <p><code>Parallel Seq Scan on orders</code>: Each worker performs a sequential scan on its portion of the table. Since there is no index, the worker must read all rows in its chunk. The filter <code>user_id = 42</code> is applied after reading each row.</p> </li> <li> <p><code>Rows Removed by Filter</code>: Shows how many rows were read but didn\u2019t match the filter. Each worker discarded millions of non-matching rows, which explains why the query is slow even with parallelism.</p> </li> <li> <p><code>actual time=10.467..460.595</code>: For this worker, it took ~10.5 ms to return the first matching row, and ~460.6 ms to finish scanning all its assigned rows. The wide gap indicates that the bulk of time is spent scanning non-matching rows.</p> </li> <li> <p><code>Execution Time: 566.946 ms</code>: This is the total time for the query including combining results from both workers. It\u2019s noticeably slower than queries on small tables, showing the cost of scanning 10M rows without an index.</p> </li> <li> <p><code>cost=0.00..145556.94</code>: Planner\u2019s estimated cost to return the first row and all rows. While not in milliseconds, a large difference between start and end suggests the planner expects significant work.</p> </li> <li> <p><code>rows=41 (actual 38)</code>: Estimated vs actual rows returned by each worker. Close numbers indicate the planner\u2019s estimates are reasonably accurate.</p> </li> <li> <p><code>width=44</code>: Average row size in bytes, which helps the planner estimate memory and I/O requirements.</p> </li> </ul> <p>Key takeaway: Without an index, every row is read even if only a few match. Parallelism helps, but the database still scans millions of rows. This makes <code>Seq Scan</code> a clear performance bottleneck, and it\u2019s exactly what an index will fix.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#optimize-with-a-single-index","title":"Optimize with a Single Index","text":"<p>To avoid scanning all 10 million rows, I will create an index on <code>user_id</code>. This allows PostgreSQL to jump directly to the matching rows.</p> <pre><code>CREATE INDEX idx_orders_user_id ON orders(user_id);\n</code></pre> <p>Note: Creating an index on 10M rows may take a few seconds to a couple of minutes depending on your machine.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#re-run-the-query-with-the-index","title":"Re-run the Query with the Index","text":"<p>Now, I rerun the same query:</p> <pre><code>EXPLAIN ANALYZE\nSELECT * FROM orders WHERE user_id = 42;\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#step-13-analyze-the-optimized-query-output","title":"Step 13: Analyze the Optimized Query Output","text":"<p>After creating the index on <code>user_id</code>, the query now returns:</p> <pre><code>Bitmap Heap Scan on orders  (cost=5.19..388.90 rows=98 width=44) (actual time=0.092..0.258 rows=113 loops=1)\n  Recheck Cond: (user_id = 42)\n  Heap Blocks: exact=110\n  -&gt;  Bitmap Index Scan on idx_orders_user_id  (cost=0.00..5.17 rows=98 width=0) (actual time=0.050..0.050 rows=113 loops=1)\n        Index Cond: (user_id = 42)\nPlanning Time: 0.174 ms\nExecution Time: 0.294 ms\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#breakdown","title":"Breakdown","text":"<ul> <li><code>Bitmap Index Scan on idx_orders_user_id</code> </li> <li>PostgreSQL scans the index first to find the matching <code>user_id = 42</code>.  </li> <li><code>Index Cond: (user_id = 42)</code> \u2192 filter is applied directly on the index.  </li> <li> <p><code>actual time=0.050..0.050</code> \u2192 scanning the index is almost instantaneous.</p> </li> <li> <p><code>Bitmap Heap Scan on orders</code> </p> </li> <li>After the index identifies matching rows, PostgreSQL retrieves the actual table rows (heap) using a bitmap of pointers.  </li> <li><code>Recheck Cond: (user_id = 42)</code> \u2192 ensures the rows from the heap still satisfy the condition (safety check).  </li> <li><code>Heap Blocks: exact=110</code> \u2192 only 110 table blocks needed to fetch 113 rows, compared to millions previously.  </li> <li> <p><code>actual time=0.092..0.258</code> \u2192 fetching the actual rows is very fast now.</p> </li> <li> <p><code>Planning Time: 0.174 ms</code> \u2192 planner quickly decided the index plan.  </p> </li> <li><code>Execution Time: 0.294 ms</code> \u2192 total time dropped from ~566 ms to less than 1 ms.  </li> </ul>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#key-observations","title":"Key Observations","text":"<ul> <li>The database no longer performs a full table scan; instead, it jumps directly to the rows via the index.  </li> <li>Only the relevant heap blocks are accessed, drastically reducing I/O.  </li> <li>Even though this is a Bitmap Heap Scan (instead of a pure Index Scan), it\u2019s still orders of magnitude faster than the previous sequential scan.  </li> </ul> <p>Takeaway: </p> <ul> <li>Adding an index on <code>user_id</code> transforms a slow query touching millions of rows into a near-instant lookup.  </li> <li>PostgreSQL smartly uses a bitmap scan to minimize disk reads when multiple rows match, balancing speed and efficiency.</li> </ul>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#explore-low-cardinality-indexes","title":"Explore Low-Cardinality Indexes","text":"<p>Some columns, like status with only a few possible values (completed, pending), have low cardinality.</p> <p>Creating a standard index on low-cardinality columns may not help much.</p> <p>You can test with:</p> <pre><code>CREATE INDEX idx_orders_status ON orders(status);\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE status = 'pending';\n</code></pre> <p>Observe whether PostgreSQL actually uses the index. Sometimes a sequential scan is faster for low-cardinality columns because the index doesn\u2019t reduce row scanning significantly.</p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#understanding-cost-vs-actual-time-in-queries","title":"Understanding Cost vs Actual Time in Queries","text":"<p>When we run <code>EXPLAIN ANALYZE</code>, PostgreSQL shows two important metrics:</p> <pre><code>Seq Scan on orders  (cost=0.00..218480.50 rows=2034870 width=44) (actual time=0.047..2097.477 rows=1999924 loops=1)\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#breakdown_1","title":"Breakdown","text":""},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#cost","title":"Cost","text":"<ul> <li> <p>cost=0.00..218480.50</p> <ul> <li>0.00 \u2192 estimated cost to return the first row</li> <li>218480.50 \u2192 estimated cost to return all rows</li> </ul> <p>Meaning: Planner\u2019s prediction of work before executing the query Units: Relative units; not milliseconds or dollars</p> </li> </ul>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#actual-time","title":"Actual Time","text":"<ul> <li> <p>actual time=0.047..2097.477</p> <ul> <li>0.047 ms \u2192 time to return the first row</li> <li>2097.477 ms \u2192 time to return all rows</li> </ul> <p>Meaning: Measured time after execution, actual query duration</p> </li> </ul> <p>**Takeaway: Not every column deserves an index; analyze cardinality and query patterns first. **</p> <p>While point of indexing is skipping values that are not relevant but if a bunch of rows have same value then we skip x but y is then too much so we have to do full table scan. </p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#solution-combine-with-a-high-cardinality-column","title":"Solution: Combine with a High-Cardinality Column","text":"<p>We can create a composite index on user_id (high cardinality) and status (low cardinality):</p> <pre><code>CREATE INDEX idx_orders_user_status\nON orders(user_id, status);\n</code></pre> <pre><code>Index Scan using idx_orders_user_status on orders  (cost=0.43..84.83 rows=20 width=44) (actual time=1.641..11.025 rows=27 loops=1)\n  Index Cond: ((user_id = 43) AND (status = 'pending'::text))\nPlanning Time: 3.779 ms\nExecution Time: 11.071 ms\n</code></pre> <ul> <li>Now the index first narrows down by user_id (selective) and then filters by status.</li> <li>Even though status alone is low cardinality, combining it with a selective column makes the index effective.</li> </ul>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#understanding-column-cardinality-queries-in-sql","title":"Understanding Column Cardinality Queries in SQL","text":"<p>1. Cardinality per User</p> <pre><code>SELECT user_id, COUNT(*) AS cardinality\nFROM orders\nGROUP BY user_id\nORDER BY cardinality DESC;\n</code></pre>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#cardinality-per-status","title":"Cardinality per Status","text":"<pre><code>SELECT COUNT(*) AS cardinality\nFROM orders\nGROUP BY status\nORDER BY cardinality DESC;\n</code></pre> <p>Whichever column has low cardinality, you can use that. </p>"},{"location":"databases/Database-Optimization-From-Indexes-to-Partitioning/#when-composite-indexes-stop-working","title":"When composite indexes stop working","text":"<p>Even with (user_id, status) composite index, if a user has millions of orders, queries like WHERE user_id = 123 AND status = 'pending' still scan many rows for that user.</p> <p>That tells us that we need to do query monitoring at the DB level cause most customers may not have that much data and for them queries may not be that slow. But there may be customers with significant number of rows that DBMS decides to use full table scan and performance degrades for that user.</p>"},{"location":"databases/optimistic-vs-pessimistic-locking/","title":"Optimistic vs Pessimistic Locking","text":""},{"location":"databases/optimistic-vs-pessimistic-locking/#optimistic-locking","title":"Optimistic Locking","text":"<p>No actual locks - relies on detecting conflicts at commit time.</p>"},{"location":"databases/optimistic-vs-pessimistic-locking/#how-it-works","title":"How It Works","text":"<ol> <li>Multiple users read the same record</li> <li>Each makes changes independently (no locks acquired)</li> <li>On update, system checks if record changed since read</li> <li>First commit wins, others get conflict error</li> </ol>"},{"location":"databases/optimistic-vs-pessimistic-locking/#example","title":"Example","text":"<pre><code>-- Read with version number\nSELECT id, name, price, version FROM products WHERE id = 1;\n-- Returns: id=1, name='Widget', price=10.00, version=5\n\n-- Update only if version matches (conflict detection)\nUPDATE products \nSET price = 12.00, version = 6\nWHERE id = 1 AND version = 5;\n\n-- If 0 rows affected \u2192 conflict! Someone else updated first\n</code></pre>"},{"location":"databases/optimistic-vs-pessimistic-locking/#when-to-use","title":"When to Use","text":"<ul> <li>Updates are infrequent</li> <li>Locking overhead is high</li> <li>Conflicts are rare and acceptable</li> </ul>"},{"location":"databases/optimistic-vs-pessimistic-locking/#pessimistic-locking","title":"Pessimistic Locking","text":"<p>Actual locks - prevents conflicts by blocking concurrent access.</p>"},{"location":"databases/optimistic-vs-pessimistic-locking/#how-it-works_1","title":"How It Works","text":"<ol> <li>User acquires lock before updating</li> <li>Other users wait until lock is released</li> <li>Updates are serialized (one after another)</li> <li>No conflicts possible</li> </ol>"},{"location":"databases/optimistic-vs-pessimistic-locking/#example_1","title":"Example","text":"<pre><code>-- Database-level lock (in transaction)\nBEGIN TRANSACTION;\nSELECT * FROM products WHERE id = 1 FOR UPDATE; -- Acquires lock\n-- Other users are now blocked from this row\nUPDATE products SET price = 12.00 WHERE id = 1;\nCOMMIT; -- Releases lock\n</code></pre>"},{"location":"databases/optimistic-vs-pessimistic-locking/#when-to-use_1","title":"When to Use","text":"<ul> <li>Updates are frequent</li> <li>Conflicts must be avoided</li> <li>Update operations are quick</li> </ul>"},{"location":"databases/optimistic-vs-pessimistic-locking/#lock-types","title":"Lock Types","text":""},{"location":"databases/optimistic-vs-pessimistic-locking/#database-locks-pessimistic","title":"Database Locks (Pessimistic)","text":"<p>Row-level lock with transaction:</p> <pre><code>BEGIN TRANSACTION;\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n</code></pre> <p>Atomic lock without transaction:</p> <pre><code>-- Single UPDATE acquires and releases lock automatically\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\n</code></pre> <p>Even without an explicit transaction, the database acquires a brief lock during the UPDATE operation to ensure atomicity.</p>"},{"location":"databases/optimistic-vs-pessimistic-locking/#quick-comparison","title":"Quick Comparison","text":"Aspect Optimistic Pessimistic Lock? No lock Yes - actual lock Conflict Detected at commit Prevented upfront Concurrency High Lower Best for Read-heavy, rare conflicts Write-heavy, must avoid conflicts Overhead Low Higher (lock management)"},{"location":"databases/optimistic-vs-pessimistic-locking/#memory-aid","title":"Memory Aid","text":"<ul> <li>Optimistic = \"Hope for the best\" (no lock, check later)</li> <li>Pessimistic = \"Expect the worst\" (lock first, prevent conflicts)</li> </ul>"},{"location":"databases/overview/","title":"Overview","text":"<ul> <li>Database Optimization From Indexes to Partitioning</li> <li>Optimistic vs Pessimistic Locking</li> </ul>"},{"location":"databases/why-use-cuid/","title":"why use CUID(Collion-resistant Unique Identifier)","text":""},{"location":"networking/","title":"Networking","text":"<ul> <li>OSI Model</li> <li>OSI layer's unit of data</li> </ul>"},{"location":"networking/osi-unit-of-data/","title":"OSI layers' unit of data","text":"<p>Different OSI layers have different unit of data.</p> OSI Layer Unit of Data Purpose Layer 7 \u2013 Application Message / Data The actual content your app cares about (HTTP request, JSON, etc.) Layer 4 \u2013 Transport Segment (TCP) / Datagram (UDP) Provides reliability, ordering, and port-based delivery Layer 3 \u2013 Network Packet Adds source/destination IP, routing info Layer 2 \u2013 Data Link Frame Adds MAC addresses, error detection (Ethernet) Layer 1 \u2013 Physical Bits Physical transmission over wire, fiber, or air"},{"location":"networking/osi/","title":"OSI model","text":"<p>OSI model is a conceptual framework to understand how the network communication between two machine works. These machines can be brower and server or server and server. But the model stays the same. </p> <p>So GET request starts from the browser towards 111.168.0.1:80 includes headers, cookies, this is application layer(layer 7).</p> <p>Then comes the presentation layer that encrypts if the encryption is enabled like with https protocol.</p> <p>Then comes the session layer, this is where session tags are added, this is how it is modeled in the OSI model but it is encrypted too.  Now session tag means these can be things like cookie or jwt tokens. That is used by statelesss server to identify request.</p> <p>But for the first time when request is sent there will not be any cookie, the cookie will be return by server and then browser will send it back with every request.</p> <p>After session layer comes the transport layer this is where connection is opened. And encrypted payload is broken down into segments. Each segment contains the source and destination port.</p> <p>Next comes the session network layer, that adds the destination and source IP and groups segements into packets. Then comes the data link layer, that adds the mac addressess for next hop. and current one which is router that your machine is using. And this layer adds the frames.</p> <p>Then comes the physical layer this is where everything gets turned into binary signals and sent over the wires and other mediums. Now current has no direction that means your frames get sent all over the world to the machine that even aren't intended recepient. But they refuse the message, this is the job of  network card. </p> <p>You source and destination ip remains same. But there maybe lots of hops(intermediary nodes between u and destination) those remove the frame.  Use routing table to get information of next machine's mac address. Source takes the address of the current hop here and destination take the mac address o the next hop/final destination whichever is closer.</p> <p>So finally when frames reach the final destination, now frames are converted to packets, then segments and decrepted and this is how it reaches the destination. </p> <p>Now when server wants to send a response, it sends that using the source IP that tells where the request came from and the same process is repeated again through the hops if there are any. LAN of course won't have any hops.</p> <p>When request leaves from browser u may have private IP but router adds the public ip of router to the frame so this is how server would know where to send back response. </p> <p>Media Access Control(MAC): Is a unique address that identifies your machine in LAN. Public IP: is what that uniquely identifies you machine/router globally.</p> <p>Have a look at the images below.</p> <p></p> <p></p> <p></p>"},{"location":"networking/osi/#example-of-end-to-end-communication-between-server-and-client","title":"Example of end to end communication between server and client:","text":"<p>Session layer has become obsolete that is why there is no mention of that here. And cookies and jwt tokens belong to appliction layer</p> <pre><code>GET /api/users HTTP/1.1\nHost: api.example.com\nAuthorization: Bearer xyz...\n```\n\n**2. TLS Encryption (Between Layers):**\n```\nEncrypt entire HTTP request using TLS\nResult: Encrypted blob (unreadable)\n```\n\n**3. TCP (Layer 4 - Transport):**\n```\nBreak encrypted blob into segments\nAdd TCP headers:\n- Source port: 54321 (random high port)\n- Dest port: 443 (HTTPS)\n- Sequence numbers for ordering\n```\n\n**4. IP (Layer 3 - Network):**\n```\nAdd IP headers:\n- Source IP: 192.168.1.100 (your private IP)\n- Dest IP: 93.184.216.34 (server public IP)\n- TTL: 64 &lt;-- this is maximum number of routers a **packet** is allowed to pass through\n```\n\n**5. Ethernet (Layer 2 - Data Link):**\n```\nAdd Ethernet frame:\n- Source MAC: Your NIC\n- Dest MAC: Router's MAC (next hop)\n```\n\n**6. Physical (Layer 1):**\n```\nConvert to electrical signals\nSend over Ethernet cable to router\n```\n\n---\n\n### **Router (NAT - Network Address Translation):**\n\n**Your statement about router adding public IP is CORRECT!**\n```\nYour machine: Private IP 192.168.1.100\nRouter: Public IP 203.0.113.50\n\nRouter's NAT table:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Internal           \u2502 External              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 192.168.1.100:54321\u2502 203.0.113.50:12345   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nOutgoing packet:\nSource: 192.168.1.100:54321 \u2192 203.0.113.50:12345\nDest: 93.184.216.34:443 (unchanged)\n\nServer sees:\nSource: 203.0.113.50:12345 (router's public IP)\nDest: 93.184.216.34:443\n```\n\n**This is why server responds to router's public IP, not your private IP.**\n\n---\n\n### **Multiple Hops:**\n\n**Your statement is CORRECT!**\n```\nHop 1: Your router (192.168.1.1)\n- Receive frame with your MAC\n- Extract IP packet\n- Look up routing table: forward to ISP\n- Build new frame with ISP router's MAC\n- Forward\n\nHop 2: ISP router (10.0.0.1)\n- Receive frame\n- Extract IP packet\n- Routing table: forward to backbone router\n- New frame, forward\n\n... (5-15 hops typical)\n\nFinal Hop: Server's router\n- Receive frame\n- Extract IP packet (dest: 93.184.216.34)\n- \"That's me!\"\n- Send to server's NIC\n```\n\n**Key insight you got RIGHT:**\n- IP addresses (source/dest) stay the same across all hops\n- MAC addresses change at every hop (next hop's MAC)\n\n---\n\n### **Response Journey:**\n```\nServer builds response:\nHTTP/1.1 200 OK\nContent-Type: application/json\nSet-Cookie: session=abc123\n\n{\"users\": [...]}\n```\n\n**Wrap in layers (reverse):**\n```\nTLS: Encrypt response\nTCP: Segment encrypted data\n    Source port: 443 (server)\n    Dest port: 12345 (router's NAT port)\nIP: Add headers\n    Source: 93.184.216.34 (server)\n    Dest: 203.0.113.50 (router's public IP)\nEthernet: Add frame headers\nPhysical: Send\n```\n\n**Router receives response:**\n```\nNAT table lookup:\nExternal port 12345 \u2192 Internal 192.168.1.100:54321\n\nRewrite packet:\nDest: 203.0.113.50:12345 \u2192 192.168.1.100:54321\n\nForward to your machine\n```\n\n**Your machine:**\n```\nLayer 1: Receive electrical signals\nLayer 2: Extract frame (MAC matches, accept)\nLayer 3: Extract IP packet (IP matches, accept)\nLayer 4: TCP reassembles segments\nTLS: Decrypt payload\nLayer 7: Browser receives HTTP response\n</code></pre>"},{"location":"security/overview/","title":"Security","text":""}]}